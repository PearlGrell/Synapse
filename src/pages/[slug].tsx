import { useRouter } from "next/router";
import { useCallback, useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import FlowEditorWrapper from "@/components/synapse/flow-editor";
import { AsyncResult, BlueprintNode, FlowData, SidebarState } from "@/types";
import "@xyflow/react/dist/style.css";
import Sidebar from "@/components/synapse/sidebar";
import ContentPanel from "@/components/synapse/content-panel";
import { JsonToFlowElements } from "@/utils/flow-conversions";

const initialAsyncState: AsyncResult<any> = { status: 'idle', data: null, error: null };
const initialFlowData: FlowData = { nodes: [], edges: [] };

export default function Home() {
  const router = useRouter();
  const { slug } = router.query;
  const autoGenerated = useRef(false);

  const [userPrompt, setUserPrompt] = useState("");
  const [promtHistory, setPromptHistory] = useState<string[]>([]);

  const [blueprintResult, setBlueprintResult] = useState<AsyncResult<BlueprintNode>>(initialAsyncState);
  const [contentResult, setContentResult] = useState<AsyncResult<string>>(initialAsyncState);

  const [flowGraph, setFlowGraph] = useState<FlowData>(initialFlowData);
  const [blueprint, setBlueprint] = useState<BlueprintNode | null>(null);

  const [isExporting, setIsExporting] = useState(false);

  useEffect(() => {
    if (blueprintResult.status === 'error') {
      toast.error(blueprintResult.error || "An error occurred while generating the blueprint.", {
        duration: 3000,
        style: {
          width: 'auto',
          textAlign: 'center'
        }
      });
    }
    if (contentResult.status === 'error') {
      toast.error(contentResult.error || "An error occurred while generating the content.", {
        duration: 3000,
        style: {
          width: 'auto',
          textAlign: 'center'
        }
      });
    }
  }, [blueprintResult, contentResult]);

  const handleGenerateBlueprint = useCallback(async (currentPrompt: string) => {
    if (!currentPrompt.trim()) {
      toast.error("Please enter a prompt to generate a blueprint.", {
        duration: 3000,
        style: {
          width: 'auto',
          textAlign: 'center'
        }
      });
      return;
    }

    setBlueprintResult({ status: 'loading', data: null, error: null });
    setContentResult(initialAsyncState);
    setFlowGraph(initialFlowData);

    try {
      const res = await fetch("/api/blueprint/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: currentPrompt }),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || "Failed to generate blueprint.");
      }

      const data = await res.json();
      setPromptHistory(prev => [...prev, currentPrompt]);
      handleBlueprintSuccess(data);
    } catch (error: any) {
      console.error("Error generating blueprint:", error);
      const errorMessage = error.message || "An unknown error occurred.";
      setBlueprintResult({ status: 'error', data: blueprint, error: errorMessage });
    }
  }, []);

  const handleUpdateBlueprint = useCallback(async (currentPrompt: string, promptHistory: string[], blueprint: any) => {
    if (!currentPrompt.trim()) {
      return;
    }

    setBlueprintResult({ status: 'loading', data: blueprint, error: null });
    setContentResult(initialAsyncState);

    try {

      const body = JSON.stringify({
        prompt: currentPrompt,
        presentJson: JSON.stringify(blueprint, null, 2),
        promptHistory: promptHistory,
      });

      const res = await fetch("/api/blueprint/update", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: body
      });

      if (res.status !== 200) {
        const errorData = await res.json();
        throw new Error(errorData.error || "Failed to update blueprint.");
      }

      const data = await res.json();
      if (!data || !data.text) {
        throw new Error("Invalid response from the server.");
      }
      setPromptHistory(prev => [...prev, currentPrompt]);
      handleBlueprintSuccess(data);
    } catch (error: any) {
      console.error("Error updating blueprint:", error);
      const errorMessage = error.message || "An unknown error occurred.";
      setBlueprintResult({ status: 'error', data: blueprint, error: errorMessage });
    }
  }, []);

  const handleBlueprintSuccess = useCallback((data: any) => {
    try {
      const blueprintObject = JSON.parse(data.text || "{}");
      if (!blueprintObject || typeof blueprintObject !== 'object') {
        throw new Error("Invalid blueprint data received.");
      }
      setBlueprint(blueprintObject);
      setBlueprintResult({ status: 'success', data: blueprintObject, error: null });
      const { nodes, edges } = JsonToFlowElements(blueprintObject);
      setFlowGraph({ nodes, edges });
    }
    catch (error) {
      console.error("Error parsing blueprint data:", error);
      setBlueprintResult({ status: 'error', data: null, error: "Failed to parse blueprint data." });
      return;
    }
  }, []);

  const handleGenerateContent = useCallback(async () => {
    if (blueprintResult.status !== 'success' || !blueprintResult.data) {
      toast.error("A blueprint must be generated first.");
      return;
    }

    setContentResult({ status: 'loading', data: null, error: null });

    try {
      const res = await fetch("/api/content/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(blueprintResult.data),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || "Failed to generate content.");
      }

      const data = await res.text();
      setContentResult({ status: 'success', data, error: null });
      toast.success("Content generated successfully!", {
        duration: 3000,
        style: {
          width: 'auto',
          textAlign: 'center'
        }
      });
    } catch (error: any) {
      console.error("Error generating content:", error);
      const errorMessage = error.message || "An unknown error occurred.";
      setContentResult({ status: 'error', data: null, error: errorMessage });
    }
  }, [blueprintResult.data, blueprintResult.status]);

  const handleExport = useCallback(async () => {
    if (contentResult.status !== 'success' || !contentResult.data) {
      toast.error("Content must be generated before exporting.");
      return;
    }
    setIsExporting(true);
    toast.info("Preparing PDF for download...", {
      duration: 1000,
      id: "exporting-content",
      style: {
        width: 'auto',
        textAlign: 'center'
      }
    });

    toast.loading("Exporting PDF...", {
      id: "exporting-content",
      duration: Infinity,
      style: {
        width: 'auto',
        textAlign: 'center'
      }
    });

    try {
      const res = await fetch("/api/content/export", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ markdown: contentResult.data, fileName: blueprintResult.data?.name || "synapse_content" }),
      });
      toast.dismiss("exporting-content");
      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${blueprintResult.data?.name.replaceAll("_ ", ": ") || "synapse_content"}.pdf`;
      a.click();
      URL.revokeObjectURL(url);
      toast.success("Content exported successfully!" + a.download, {
        duration: 3000,
        style: {
          width: 'auto',
          textAlign: 'center'
        }
      });
    } catch (error: any) {
      console.error("Error exporting content:", error);
      const errorMessage = error.message || "An unknown error occurred while exporting.";
      setContentResult({ status: 'error', data: null, error: errorMessage });
    }
    finally {
      toast.dismiss();
    }

    setIsExporting(false);
  }, [contentResult.data, contentResult.status]);

  const handleReset = useCallback(() => {
    setUserPrompt("");
    setBlueprint(null);
    setBlueprintResult(initialAsyncState);
    setContentResult(initialAsyncState);
    setFlowGraph(initialFlowData);
  }, []);

  useEffect(() => {
    const slugStr = Array.isArray(slug) ? slug[0] : slug;
    if (slugStr && !autoGenerated.current) {
      const decodedPrompt = decodeURIComponent(slugStr.replace(/-/g, ' '));
      setUserPrompt(decodedPrompt);

      handleGenerateBlueprint(decodedPrompt);
      autoGenerated.current = true;
    }
  }, [slug]);

  const isGenerating = blueprintResult.status === 'loading' || contentResult.status === 'loading';
  const hasGeneratedBlueprint = blueprintResult.status === 'success';

  return (
    <div className="flex h-screen flex-row">
      <Sidebar userPrompt={userPrompt}
        setUserPrompt={setUserPrompt}
        isGenerating={isGenerating}
        blueprintResult={blueprintResult}
        hasGeneratedBlueprint={hasGeneratedBlueprint}
        contentResult={contentResult}
        handleGenerateBlueprint={handleGenerateBlueprint}
        handleGenerateContent={handleGenerateContent}
        handleExport={handleExport}
        isExporting={isExporting}
      />

      <main className="flex-1 overflow-y-auto bg-white text-black">
        <FlowEditorWrapper
          edges={flowGraph.edges}
          nodes={flowGraph.nodes}
          disabled={!blueprintResult.data}
          generating={blueprintResult.status === 'loading'}
          onUpdateBlueprint={handleUpdateBlueprint}
          onReset={handleReset}
          blueprint={blueprintResult.data}
          promptHistory={promtHistory}
        />
      </main>

      {contentResult.status !== 'idle' && (
        <ContentPanel
          contentResult={contentResult}
          isGenerating={isGenerating}
          handleGenerateContent={handleGenerateContent}
        />
      )}
    </div>
  );
}